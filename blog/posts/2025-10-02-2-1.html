<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Django에 Celery 사용하기(1) - 박나은</title>
    <meta name="description" content="회사에서 진행했던 일들 정리(2): Celery 개념 정리">
    <meta property="og:title" content="Django에 Celery 사용하기(1)">
    <meta property="og:description" content="회사에서 진행했던 일들 정리(2): Celery 개념 정리">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="../../images/favicon/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../../images/favicon/favicon.svg" />
    <link rel="shortcut icon" href="../../images/favicon/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../../images/favicon/apple-touch-icon.png" />
    <link rel="manifest" href="../../images/favicon/site.webmanifest" />
    
    <link rel="stylesheet" href="../../assets/css/styles.css">
    <link rel="stylesheet" href="../../assets/css/blog-post.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <nav class="nav-container">
        <div class="nav-content">
            <a class="nav-brand" href="../../index.html">박나은</a>
            <div class="nav-tabs">
                <a class="nav-tab" href="../blog-index.html">Blog</a>
            </div>
        </div>
    </nav>
    
    <div class="main-container">
        <article class="blog-post-full">
            <header class="post-header">
                <h1 class="post-title">Django에 Celery 사용하기(1)</h1>
                <div class="post-meta">
                    <span>📅 2025년 10월 2일</span>
                    <span>⏱️ 5분 읽기</span>
                    <span>📁 Tech</span>
                </div>
                <div class="post-tags">
                    <span class="post-tag">#python</span><span class="post-tag">#Celery </span>
                </div>
            </header>
            <div class="post-content">
                <h1 id="회사에서-진행했던-일들-정리2">회사에서 진행했던 일들 정리(2)</h1>
<p>데이터 관리 웹 구축 시 가장 많이 사용했던 Celery.<br>대용량 데이터 업로드/다운로드/일괄 변경/예약 작업 등 많은 작업에 활용했는데<br>안 써놓으면 까먹을 것 같아서 정리해보았다.  </p>
<h2 id="❓-celery-란">❓ Celery 란?</h2>
<p> <strong>Celery</strong>:  Python으로 작성된 분산 작업 큐(Distributed Task Queue) 시스템. 주로  Python application 에서 비동기 작업 실행, 실시간 작업 처리,예약된 작업 실행을 위해 사용된다. 
 <details>
 <summary>작업 큐(Task Queue) 란?</summary></p>
<p>  Celery 공식 문서에서는 &quot;Task queues are used as a mechanism to distribute work across threads or machines.&quot; 라고 나와 있다.</p>
<p>  스레드나 머신에 작업을 분산하는 메커니즘 이라는 말인데. 쉽게 정리하자면 소프트웨어 시스템에서 시간이 오래 걸리거나 리소스를 많이 소모하는 작업을 바로 처리하지 않고 비동기적으로 처리하도록 미루어두는 것이다.</p>
<p>  실제 큐(Queue) 자료 구조와 유사하게 생산자-소비자(Producer-Consumer) 모델을 기반으로 작동한다.
 </details></p>
<h4 id="ℹ️-celery의-작동-구조">ℹ️ Celery의 작동 구조</h4>
<p> Celery의 는 클라이언트(혹은 애플리케이션)/ 메시지 브로커(Message Broker)/ 워커(Worker)/ 백엔드(Result Backend) 로 구성된다.<br> 이때 백엔드는 선택 사항에 가깝다.<br> 작동 순서는 밑과 같다.  </p>
<ol>
<li>클라이언트에서 Celery 를 통해 Task(작업)을 발행(Publish), 비동기적으로 실행하도록 요청</li>
<li>메세지 브로커에서 task 메세지를 받고 이에 대한 정보를 브로커의 큐에 저장</li>
<li>큐에 새로운 Task 메시지가 들어오면, 워커가 이를 가져와서(Consume) 실제로 Task에 정의된 함수를 실행</li>
<li>워커가 Task를 처리한 결과나 상태를 백엔드에 저장</li>
</ol>
<p>이를 머메이드로 나타내면 밑과 같다.  </p>
<pre><code class="language-mermaid">    graph TB
        subgraph &quot;클라이언트 애플리케이션&quot;
            Client[Django/Flask 등&lt;br/&gt;웹 애플리케이션]
        end
        
        subgraph &quot;메시지 브로커&quot;
            Broker[Message Broker&lt;br/&gt;Redis/RabbitMQ]
            Queue1[Task Queue 1]
            Queue2[Task Queue 2]
            Queue3[Task Queue 3]
        end
        
        subgraph &quot;Celery Workers&quot;
            Worker1[Worker 1]
            Worker2[Worker 2]
            Worker3[Worker 3]
        end
        
        subgraph &quot;결과 백엔드&quot;
            Backend[Result Backend&lt;br/&gt;Redis/Database]
        end
        
        Client --&gt;|1. Task 생성 및 전송| Broker
        Broker --&gt; Queue1
        Broker --&gt; Queue2
        Broker --&gt; Queue3
        
        Queue1 -.-&gt;|2. Task 가져오기| Worker1
        Queue2 -.-&gt;|2. Task 가져오기| Worker2
        Queue3 -.-&gt;|2. Task 가져오기| Worker3
        
        Worker1 --&gt;|3. 결과 저장| Backend
        Worker2 --&gt;|3. 결과 저장| Backend
        Worker3 --&gt;|3. 결과 저장| Backend
        
        Backend -.-&gt;|4. 결과 조회| Client
        
        style Client fill:#e1f5ff
        style Broker fill:#fff4e1
        style Backend fill:#f0e1ff
        style Worker1 fill:#e1ffe1
        style Worker2 fill:#e1ffe1
        style Worker3 fill:#e1ffe1
</code></pre>
<h2 id="🤔-왜-celery-를-사용했는가">🤔 왜 Celery 를 사용했는가?</h2>
<p> 당시 파일 업로드/ 다운로드 / 파일명 일괄 변경 등등 대용량&amp;다량의 파일들을 백그라운드에서 처리해야 하는 문제가 있었다.<br> Django가 비동기 처리를 지원하긴 하는데... 나는 백그라운드에서 처리할 수 있어야 한다 + 파일 처리 등 시간이 오래 걸리는 작업을 단순히 Django에서 지원하는 비동기 뷰로 처리할 수 있는지 모르겠다는 이유로 Celery를 사용했다.<br> 접근 방식은 100개 이상/총 용량 500mb 이상의 데이터를 다뤄야 할 경우 Celery를 사용하도록 하는 거였고 밑과 같이 구현했다.  </p>
<pre><code>사용자 요청→Django 뷰→Celery Task 발행→사용자에게 즉시 응답(백그라운드) →Celery 워커가 Task 처리 → 결과 저장/알림
</code></pre>
<h4 id="✅-장점">✅ 장점</h4>
<ol>
<li><p>비동기 및 백그라운드 처리 (Asynchronous Processing): 시간이 오래 걸리는 작업을 백그라운드로 넘겨서 응답 시간을 줄이고, 작업 완료를 기다리지 않고 앱을 계속 사용하는 것이 가능하다.</p>
</li>
<li><p>확장성 및 분산 처리 (Scalability &amp; Distributed Processing): 작업 부하가 늘어나면 워커 프로세스나 서버(멀티 디바이스) 수를 쉽게 늘려 처리량을 증가시킬 수 있고, 작업을 여러 워커에 분산시켜 처리하므로 단일 서버 과부하를 방지할 수 있다.</p>
</li>
<li><p>신뢰성 및 내결함성 (Reliability &amp; Fault Tolerance): Task 정보가 메시지 브로커에 저장되므로, 웹 서버나 워커가 다운되어도 작업이 유실되지 않고 복구 후 재처리될 수 있다. 또한 외부 서비스 통신 실패 등의 일시적인 오류 발생 시, Task의 자동 재시도 로직을 쉽게 구현할 수 있다.</p>
</li>
<li><p>스케줄링 (Scheduling): Celery Beat 컴포넌트를 사용하여 특정 시간에 실행하거나 주기적으로 반복 실행해야 하는 작업(크론 작업)을 쉽게 설정할 수 있다.</p>
</li>
</ol>
<h4 id="❌-단점">❌ 단점</h4>
<p> 단점은 하나다. 어플리케이션 구조가 정말 복잡해진다.<br> 일단 시스템에 새로운 계층 하나가 더 추가되는 거라서..<br> Celery는 기본적으로 메세지 브로커로 쓸 RabbitMQ, Redis 등을 설치해야 하는데다가 Celery의 워커 관리도 처음 하면 좀 복잡하다.<br> 거기에 chain,Chord,Group 등 과 같은 워크플로우 구성 기능까지 쓴다고 하면 여러모로 신경쓸 것도 많고 굉장히 복잡해진다.  </p>
<h2 id="💡-어떻게-쓰면-되지">💡 어떻게 쓰면 되지?</h2>
<p> Django에 적용하는 방법은 공식문서의 <a href="https://docs.celeryq.dev/en/stable/django/first-steps-with-django.html#django-first-steps">First steps with Django</a>에 자세하게 나와 있다.<br> 이걸 참고해서 Django에 적용하는건 다음에 자세하게 쓰도록 하고, 여기서는 도커를 사용한 설치 방법과 사용 예제만 가볍게 적어보았다.  </p>
<h4 id="설치">설치</h4>
<p>Celery와 메시지 브로커(여기서는 Redis)를 위한 Python 라이브러리를 설치한다.</p>
<pre><code class="language-bash"># Celery 및 Redis 백엔드용 라이브러리 설치
pip install &quot;celery[redis]&quot;
</code></pre>
<h4 id="celery-앱-생성-celery_apppy">Celery 앱 생성 (<code>celery_app.py</code>)</h4>
<p>Celery 인스턴스를 생성하고 사용할 브로커와 백엔드를 설정한다.</p>
<pre><code class="language-python">from celery import Celery

# Redis 브로커와 백엔드 사용 예시
# Windows에서는 Redis를 로컬 설치 대신 Docker 사용을 권장
app = Celery(
    &quot;my_app&quot;,
    broker=&quot;redis://localhost:6379/0&quot;,
    backend=&quot;redis://localhost:6379/1&quot;,  # FastAPI/Django 등과 함께 사용 가능
)
</code></pre>
<h4 id="task-정의-taskspy">Task 정의 (<code>tasks.py</code>)</h4>
<p>실제로 백그라운드에서 실행할 작업을 정의한다.</p>
<pre><code class="language-python">from celery_app import app

# @app.task 데코레이터를 사용하여 일반 함수를 Celery Task로 만든다.
@app.task
def add(x, y):
    return x + y
</code></pre>
<h4 id="celery-워커-실행">Celery 워커 실행</h4>
<pre><code class="language-bash">celery -A celery_app worker --loglevel=info
</code></pre>
<p>이 명령어를 실행하면 워커가 시작되고, 브로커가 새로운 Task를 기다리는 상태가 된다.
이후 다른 스크립트/뷰 등에서 task를 비동기적으로 호출하여 사용하면 된다.</p>
<pre><code class="language-python">from tasks import add

# Task를 비동기적으로 실행 요청 (.delay()는 apply_async()의 간이 버전)
result = add.delay(4, 6)

# Task의 결과를 확인하려면 .get() 사용 (프로덕션에서는 타임아웃/예외 처리 권장)
try:
    final_result = result.get(timeout=10)  # 최대 10초 대기
    print(f&quot;Task 결과: {final_result}&quot;)
except Exception as e:
    print(f&quot;Task 실행 중 오류 발생 또는 타임아웃: {e}&quot;)
</code></pre>

            </div>
            <footer class="post-footer">
                <div class="post-navigation">
                    <a href="../blog-index.html" class="back-to-blog">← 블로그로 돌아가기</a>
                </div>
            </footer>
        </article>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <!-- Mermaid 라이브러리 추가 -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        // Mermaid 초기화 및 렌더링
        mermaid.initialize({ 
            startOnLoad: false,
            theme: 'default',
            securityLevel: 'loose'
        });
        
        // 페이지 로드 후 실행
        window.addEventListener('DOMContentLoaded', function() {
            // language-mermaid 클래스를 가진 코드 블록 찾기
            document.querySelectorAll('pre code.language-mermaid').forEach(function(codeElement) {
                const pre = codeElement.parentElement;
                const mermaidCode = codeElement.textContent;
                
                // 새로운 mermaid div 생성
                const mermaidDiv = document.createElement('div');
                mermaidDiv.className = 'mermaid';
                mermaidDiv.textContent = mermaidCode;
                
                // pre 태그를 mermaid div로 교체
                pre.parentNode.replaceChild(mermaidDiv, pre);
            });
            
            // Mermaid 렌더링
            mermaid.init(undefined, document.querySelectorAll('.mermaid'));
        });
    </script>
</body>
</html>