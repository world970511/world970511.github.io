<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAG를 활용한 웹소설 추천 시스템 구현하기(2) - 박나은</title>
    <meta name="description" content="개인 프로젝트 기록: 험난한 Skyvern 사용 후기와 사용을 포기한 이유">
    <meta property="og:title" content="RAG를 활용한 웹소설 추천 시스템 구현하기(2)">
    <meta property="og:description" content="개인 프로젝트 기록: 험난한 Skyvern 사용 후기와 사용을 포기한 이유">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="../../images/favicon/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../../images/favicon/favicon.svg" />
    <link rel="shortcut icon" href="../../images/favicon/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../../images/favicon/apple-touch-icon.png" />
    <link rel="manifest" href="../../images/favicon/site.webmanifest" />
    
    <link rel="stylesheet" href="../../assets/css/styles.css">
    <link rel="stylesheet" href="../../assets/css/blog-post.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <nav class="nav-container">
        <div class="nav-content">
            <a class="nav-brand" href="../../index.html">박나은</a>
            <div class="nav-tabs">
                <a class="nav-tab" href="../blog-index.html">Blog</a>
            </div>
        </div>
    </nav>
    
    <div class="main-container">
        <article class="blog-post-full">
            <header class="post-header">
                <h1 class="post-title">RAG를 활용한 웹소설 추천 시스템 구현하기(2)</h1>
                <div class="post-meta">
                    <span>📅 2025년 11월 25일</span>
                    <span>⏱️ 5분 읽기</span>
                    <span>📁 Project</span>
                </div>
                <div class="post-tags">
                    <span class="post-tag">#Crawler</span><span class="post-tag">#Skyvern</span><span class="post-tag">#data process</span>
                </div>
            </header>
            <div class="post-content">
                <h1 id="rag를-활용한-웹소설-추천-시스템-구현하기2">RAG를 활용한 웹소설 추천 시스템 구현하기(2)</h1>
<p>대충 시스템이 굴러가니 이제 데이터를 수집해야 한다.
수집 기준은</p>
<ul>
<li>시리즈/카카오페이지/리디북스의 유료연재작</li>
<li>제목/작가/소개글/플랫폼/url(세부페이지)/키워드 수집</li>
<li>여러 플랫폼에 중복되어 연재되는 작품인 경우 플랫폼에 추가</li>
<li>완결/연재 여부는 수집하지 않음</li>
<li>성인판/단행본/개정판 여부는 상관하지 않음. 같은 제목/작가인 경우 중복 데이터로 처리</li>
</ul>
<p>로 일단 정했는데 무료 연재까지 수집할 경우에는 케이스가 너무 많아져서(작가 사정으로 연재 중단되는 경우 등) 유료 연재작으로 골랐고 플랫폼도 유료 연재작이 많은 곳으로 세 곳을 골랐다.<br>이렇게 기준을 정했으면 이제 남은 것은... 수집이다.</p>
<h2 id="📌-험난한-skyvern-사용기">📌 험난한 Skyvern 사용기</h2>
<p>사실 원래 크롤링을 하려면 Selenium/BeautifulSoup/Scrapy 등을 많이 사용한다. 원래 크롤링 관련한 라이브러리에 대한 건 밑에 따로 정리해두었다.  </p>
<details>
<summary>크롤링 라이브러리 정리</summary>
 </details>
하지만 이번에 조금 골이 아팠던 건 여러 플랫폼에서 데이터를 수집해야 하는데 각기 다른 웹 구조를 갖고 있다는 거였다.  
아무리 AI 도움을 받는다고 해도 플랫폼 3개 크롤러 만들기는 약간 힘들고 귀찮은 일이긴 해서..(중간에 웹사이트 구조 바뀐다든가 이런 것들 고려해보면...)
그래서 조금 더 쉽게 데이터를 추출할 방도가 없을까 하다가 링크드인에서 Skyvern에 대한 소개를 보고 이번에 한번 적용해보았다.  

<h4 id="❓skyvern-이란">❓Skyvern 이란?</h4>
<p><a href="https://www.skyvern.com/docs/introduction">공식 문서</a>에 따르면, &#39;Skyvern은 LLM과 컴퓨터 비전 기술을 활용해 브라우저 기반의 워크플로우를 자동화하는 도구&#39;라고 한다.<br>더 쉽게 말하자면, 프롬프트 + 컴퓨터 비전+ LLM을 활용해서 웹사이트의 현재 화면에 있는 요소를 실시간으로 분석하고 이해하며 자동으로 작업을 처리하는 도구다.<br>웹사이트 구조를 이해하고 파서를 처리하는 부분을 따로 넣을 필요 없이 원하는 웹사이트 주소 + 프롬프트를 넣어서 작업을 진행하면 된다. </p>
<h4 id="✅-장점">✅ 장점</h4>
<ul>
<li><p><strong>처음 보는 웹사이트도 작동 가능</strong>: 별도의 커스텀 코드 없이도 시각적 요소를 필요한 행동과 매핑하여 워크플로우를 완료할 수 있습니다.</p>
</li>
<li><p><strong>레이아웃 변경에 강력함</strong>: 미리 정해진 XPath나 셀렉터를 찾아다니는 방식이 아니기 때문에, 웹사이트 구조가 변경되어도 유연하게 대처합니다.</p>
</li>
<li><p><strong>높은 확장성</strong>: 워크플로우 수행에 필요한 상호작용을 스스로 추론할 수 있어, 하나의 워크플로우 로직을 수많은 웹사이트에 범용적으로 적용할 수 있습니다.</p>
</li>
</ul>
<h4 id="❌-단점">❌ 단점</h4>
<ul>
<li><strong>로컬 설정이 너무 어렵다.</strong>: </li>
<li><strong>속도가 빠르진 않다</strong>:</li>
</ul>
<h2 id="ℹ️-작동-구조-및-원리">ℹ️ 작동 구조 및 원리</h2>
<h2 id="🔚-결과">🔚 결과</h2>
<p>일단 나는 Ollama와 Docker를 사용해서 브라우저를 띄운 후 작업하는 식으로 진행하긴 했고 20개 정도 추출에 성공하긴 했는데.....
아무래도 속도가 너무 느렸다.</p>

            </div>
            <footer class="post-footer">
                <div class="post-navigation">
                    <a href="../blog-index.html" class="back-to-blog">← 블로그로 돌아가기</a>
                </div>
            </footer>
        </article>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <!-- Mermaid 라이브러리 추가 -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        // Mermaid 초기화 및 렌더링
        mermaid.initialize({ 
            startOnLoad: false,
            theme: 'default',
            securityLevel: 'loose'
        });
        
        // 페이지 로드 후 실행
        window.addEventListener('DOMContentLoaded', function() {
            // language-mermaid 클래스를 가진 코드 블록 찾기
            document.querySelectorAll('pre code.language-mermaid').forEach(function(codeElement) {
                const pre = codeElement.parentElement;
                const mermaidCode = codeElement.textContent;
                
                // 새로운 mermaid div 생성
                const mermaidDiv = document.createElement('div');
                mermaidDiv.className = 'mermaid';
                mermaidDiv.textContent = mermaidCode;
                
                // pre 태그를 mermaid div로 교체
                pre.parentNode.replaceChild(mermaidDiv, pre);
            });
            
            // Mermaid 렌더링
            mermaid.init(undefined, document.querySelectorAll('.mermaid'));
        });
    </script>
</body>
</html>