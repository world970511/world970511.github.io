<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Warehouse and BigQuery - 박나은</title>
    <meta name="description" content="Data Engineering Zoomcamp 2026 스터디 정리">
    <meta name="google-site-verification" content="lb30pDDWow-sRJaP0kOtYGGmFU5NTD9i_hNGZIeWHlM" />
    <meta property="og:title" content="Data Warehouse and BigQuery">
    <meta property="og:description" content="Data Engineering Zoomcamp 2026 스터디 정리">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="../../images/favicon/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../../images/favicon/favicon.svg" />
    <link rel="shortcut icon" href="../../images/favicon/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../../images/favicon/apple-touch-icon.png" />
    <link rel="manifest" href="../../images/favicon/site.webmanifest" />
    
    <link rel="stylesheet" href="../../assets/css/styles.css">
    <link rel="stylesheet" href="../../assets/css/blog-post.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <nav class="nav-container">
        <div class="nav-content">
            <a class="nav-brand" href="../../index.html">박나은</a>
            <div class="nav-tabs">
                <a class="nav-tab" href="../blog-index.html">Blog</a>
            </div>
        </div>
    </nav>
    
    <div class="main-container">
        <article class="blog-post-full">
            <header class="post-header">
                <h1 class="post-title">Data Warehouse and BigQuery</h1>
                <div class="post-meta">
                    <span>📅 2026년 2월 9일</span>
                    <span>⏱️ 5분 읽기</span>
                    <span>📁 Tech</span>
                </div>
                <div class="post-tags">
                    <span class="post-tag">#Data Warehouse</span><span class="post-tag">#BigQuery</span>
                </div>
            </header>
            <div class="post-content">
                <h1 id="data-warehouse-and-bigquery">Data Warehouse and BigQuery</h1>
<p>Data Engineering Zoomcamp 2026 스터디의 모듈3 내용을 정리했다. </p>
<h2 id="olap-vs-oltp">OLAP vs OLTP</h2>
<ul>
<li><strong>OLTP-Online Transaction Processing</strong> (온라인 트랜젝션 프로세싱): 데이터 입력, 수정, 삭제 등의 실시간으로 사용자의 데이터를 갱신하거나 조회하는 단위의 작업 방식</li>
<li><strong>OLAP-Online Analytical Processing</strong> (온라인 분석 프로세싱): 데이터 웨어하우스 기반의 의사 결정 및 통계</li>
</ul>
<p>이를 표로 다시 정리해보자.</p>
<table>
<thead>
<tr>
<th></th>
<th>OLTP</th>
<th>OLAP</th>
</tr>
</thead>
<tbody><tr>
<td>목적</td>
<td>실시간으로 필수적인 비즈니스 운영을 제어하고 실행</td>
<td>계획 수립, 문제 해결, 의사 결정 지원, 숨겨진 인사이트 발견</td>
</tr>
<tr>
<td>데이터 업데이트</td>
<td>사용자에 의해 시작되는 짧고 빠른 업데이트</td>
<td>예약된 장기 실행 배치 작업으로 주기적으로 데이터 갱신</td>
</tr>
<tr>
<td>데이터베이스 설계</td>
<td>효율성을 위해 정규화된 데이터베이스</td>
<td>분석을 위해 비정규화된 데이터베이스</td>
</tr>
<tr>
<td>공간 요구 사항</td>
<td>과거 데이터가 보관(아카이빙)되면 일반적으로 작음</td>
<td>대규모 데이터 세트 집계로 인해 일반적으로 큼</td>
</tr>
<tr>
<td>백업 및 복구</td>
<td>비즈니스 연속성 보장 및 법적/거버넌스 요건 충족을 위해 정기적인 백업 필수</td>
<td>정기 백업 대신 필요시 OLTP 데이터베이스에서 손실된 데이터를 다시 로드 가능</td>
</tr>
<tr>
<td>생산성</td>
<td>최종 사용자의 생산성 향상</td>
<td>비즈니스 관리자, 데이터 분석가, 경영진의 생산성 향상</td>
</tr>
<tr>
<td>데이터 뷰</td>
<td>일상적인 비즈니스 트랜잭션 나열</td>
<td>엔터프라이즈 데이터의 다차원적 뷰</td>
</tr>
<tr>
<td>사용자 예시</td>
<td>고객 응대 직원, 사무원, 온라인 쇼핑객</td>
<td>데이터 분석가, 비즈니스 분석가, 경영진 같은 지식 근로자</td>
</tr>
</tbody></table>
<h2 id="💡-data-warehouse-란">💡 Data Warehouse 란?</h2>
<p>데이터 웨어하우스는 데이터를 수집하고, 정리하고, 분석할 수 있는 데이터 저장소를 의미한다.<br>그럼 여기서 의문점이 생긴다. 대체 데이터 웨어하우스, 데이터 레이크, 데이터 마트가 무슨 차이가 있고, 왜 이런 식으로 구분하는가?<br>그래서 이번에 아예 각각의 정의와 차이점을 정리해보았다.  </p>
<h4 id="1️⃣-data-warehouse">1️⃣ Data Warehouse</h4>
<ul>
<li>기업의 의사결정을 지원하기 위해 다양한 운영 시스템(OLTP)에서 데이터를 추출하여 <strong>중앙 집중식으로 통합한 데이터 저장소</strong></li>
<li>특징:<ul>
<li>**구조화된 데이터(Structured Data)**를 주로 다루며, 데이터를 저장하기 전에 스키마를 미리 정의하는 Schema-on-write 방식을 따름</li>
<li>분석 처리(OLAP)를 위해 최적화되어 있으며, 트랜잭션 처리 시스템(OLTP)과 분리되어 운영됨</li>
</ul>
</li>
<li>목적: 비즈니스 인텔리전스(BI), 정형화된 리포팅, 역사적 데이터 분석 등 경영진의 의사결정을 지원</li>
</ul>
<h4 id="2️⃣-data-lake">2️⃣ Data Lake</h4>
<ul>
<li>정형, 반정형, 비정형 데이터를 포함한 <strong>모든 형태의 데이터를 원시(Raw) 상태 그대로 저장</strong>하는 대규모 중앙 저장소</li>
<li>특징:<ul>
<li>데이터를 가공하지 않고 원본 그대로 저장하며, 데이터를 읽을 때 스키마를 정의하는 Schema-on-read 방식을 사용</li>
<li><strong>비정형 데이터(텍스트, 이미지, 로그 등)</strong> 를 포함한 모든 종류의 데이터를 수용 가능</li>
<li>저장소와 컴퓨팅을 분리하여 저렴한 비용으로 무제한에 가까운 확장이 가능</li>
</ul>
</li>
<li>목적: 데이터 과학자나 엔지니어가 머신러닝, 탐색적 데이터 분석, 스트리밍 분석 등을 수행하기 위해 사용</li>
<li>주의점: 메타데이터 관리나 데이터 거버넌스가 부재할 경우, 데이터가 무엇인지 알 수 없는 <strong>데이터 늪(Data Swamp)</strong> 이 될 위험이 있음</li>
</ul>
<h4 id="3️⃣-data-mart">3️⃣ Data Mart</h4>
<ul>
<li>데이터 마트는 데이터 웨어하우스의 하위 집합으로, <strong>특정 부서나 비즈니스 기능(예: 마케팅, 영업, 재무)을 위해 특화</strong> 된 데이터 저장소</li>
<li>정의 및 특징:<ul>
<li>전사적인 데이터를 다루는 웨어하우스와 달리, **특정 주제 영역(Subject Area)**이나 단일 커뮤니티에 초점을 맞춤  </li>
<li>데이터 웨어하우스보다 규모가 작으며(수십 GB 수준), 구축이 상대적으로 빠름  </li>
<li>사용자가 필요한 데이터에 더 빠르고 쉽게 접근할 수 있도록 요약된 데이터를 포함하기도 함</li>
</ul>
</li>
<li>구축 방식:<ul>
<li>Top-down: 데이터 웨어하우스에서 데이터를 추출하여 마트를 구성하는 방식  </li>
<li>Bottom-up: 부서별로 데이터 마트를 먼저 구축하고 이를 통합해 나가는 방식</li>
</ul>
</li>
</ul>
<p>이를 표로 정리하면 밑과 같다.</p>
<p>다른 의문들은 따로 정리해보았다.</p>
<details>
<summary>데이터셋과 데이터 마트의 차이점은?</summary>

<p><strong>데이터 마트 (Data Mart)</strong> 
    - 성격: 저장 시스템 / 인프라<br>    - 지속성: 영구적 (지속적으로 업데이트됨)<br>    - 주요 사용자: 현업 부서, BI 담당자<br>    - 구조적 특징: 관계형 DB, 스타 스키마 (테이블 간 관계 중요)<br>    - 관계: 데이터셋을 추출하는 원천(Source)  </p>
<p><strong>데이터셋 (Dataset)</strong>
    - 성격: 데이터 객체 / 파일 / 입력물<br>    - 지속성: 일시적 (특정 분석 시점에 추출/사용됨)<br>    - 주요 사용자: 데이터 과학자, 머신러닝 엔지니어<br>    - 구조적 특징: 행(Sample)과 열(Feature)로 구성된 매트릭스<br>    - 관계: 데이터 마트에서 추출된 결과물(Output)  </p>
<p>결론적으로, 데이터 엔지니어가 특정 부서가 사용하기 편하게 데이터를 정리해 둔 창고가 **&#39;데이터 마트&#39;**라면, 데이터 과학자가 그 창고에서 꺼내와서 AI 모델 학습을 위해 코드로 불러들인 데이터 덩어리가 **&#39;데이터셋&#39;**이다.</p>
</details>
<br/>

<details>
<summary>데이터베이스와 데이터 웨어하우스의 관계는 어떻게 되는 걸까?</summary>

<p><strong>데이터베이스</strong>: 특정 비즈니스 영역에 해당하는 데이터를 저장한다. 
<strong>데이터 웨어하우스:</strong> 비즈니스 전체에 해당하는 현재 및 이력 데이터를 저장하며 BI와 분석을 제공한다.<br>데이터 웨어하우스는 데이터베이스 서버를 사용해 기업 데이터베이스에서 데이터를 가져오고 데이터 모델링, 데이터 수명주기 관리, 데이터 소스 통합 등을 위한 추가적인 기능을 갖추고 있다.</p>
<p>다시 정리하자면, 데이터베이스는 데이터를 생산하는 **&#39;공급처(Source)&#39;**이고, 데이터 웨어하우스는 그 데이터를 모아서 분석하는 **&#39;최종 저장소(Destination)&#39;**라는 점이다.</p>
</details>
<br/>


<h2 id="💡-bigquery-란-">💡 BigQuery 란 ?</h2>
<p>BigQuery는 구글 클라우드에서 제공하는 데이터 웨어하우스 서비스이다.<br>밑과 같은 특징을 가지고 있다.</p>
<ul>
<li><strong>서버리스 데이터 웨어하우스 (Serverless Data Warehouse):</strong> 관리해야 할 서버가 없으며, 별도의 데이터베이스 소프트웨어를 설치할 필요가 없는 구조입니다.</li>
<li><strong>통합 인프라 및 소프트웨어:</strong> 확장성(Scalability)과 고가용성(High-availability)을 포함하여 소프트웨어와 인프라 전반을 서비스로 제공합니다.</li>
<li><strong>내장형 분석 기능:</strong> 머신러닝(ML), 지리 공간 분석(Geospatial analysis), 비즈니스 인텔리전스(BI)와 같은 고급 기능이 플랫폼 내에 기본적으로 탑재되어 있습니다.</li>
<li><strong>컴퓨트와 스토리지의 분리:</strong> BigQuery는 데이터를 분석하는 연산(Compute) 엔진과 데이터를 저장하는 **스토리지(Storage)**를 분리하여 유연성을 극대화합니다</li>
</ul>
<p>비슷한 데이터 서비스로는 Amazon Athena 정도를 살펴볼 수 있다. </p>
<h4 id="✅-클러스터링과-파티셔닝">✅ 클러스터링과 파티셔닝</h4>
<p>일단 파티셔닝/ 클러스터링은 원래 데이터베이스에서 사용하던 개념이다.<br>이에 대한 내용은 밑에 작게 정리해보았다.</p>
<details>
<summary>파티셔닝과 클러스터링</summary>

<p><strong>파티셔닝(Partitioning)</strong></p>
<ul>
<li>대용량 테이블을 논리적으로 더 작은 단위(파티션)로 분할하는 기술</li>
<li>파티션 키(Partition Key)를 기준으로 데이터를 분할</li>
<li>예: 날짜, 지역 코드 등</li>
<li>장점:<ul>
<li>쿼리 성능 향상 (필요한 파티션만 스캔)</li>
<li>비용 절감 (스캔하는 데이터 양 감소)</li>
<li>데이터 관리 용이 (파티션 단위 백업/복구)</li>
</ul>
</li>
</ul>
<p><strong>클러스터링(Clustering)</strong></p>
<ul>
<li>파티션 내에서 데이터를 특정 컬럼 기준으로 정렬하는 기술</li>
<li>클러스터 키(Cluster Key)를 기준으로 데이터 정렬</li>
<li>예: 사용자 ID, 상품 코드 등</li>
<li>장점:<ul>
<li>쿼리 성능 향상 (정렬된 데이터 접근)</li>
<li>비용 절감 (스캔하는 데이터 양 감소)</li>
<li>데이터 분석 용이 (특정 컬럼 기준 집계)</li>
</ul>
</li>
</ul>
</details>
<br/>

<p>그렇다면, BigQuery에서 파티셔닝과 클러스터링은 어떻게 동작하는지 알아보자.</p>
<p><strong>빅쿼리 파티셔닝 (Partitioning)</strong></p>
<ul>
<li>테이블을 특정 컬럼(주로 날짜, 타임스탬프, 정수)을 기준으로 작은 세그먼트로 나눕니다.</li>
<li>쿼리 실행 시 WHERE 절 조건에 맞는 파티션만 읽도록 하여(Pruning), 스캔하는 데이터 양을 줄이고 비용을 절감하며 쿼리 속도를 높입니다.</li>
<li>사용자가 명시적으로 파티션을 나누어 관리할 수 있습니다.</li>
</ul>
<p><strong>빅쿼리 클러스터링 (Clustering)</strong></p>
<ul>
<li>테이블(또는 파티션) 내에서 지정된 **클러스터 키(Cluster Key)**를 기준으로 데이터를 정렬하여 저장.</li>
<li>매우 큰 데이터셋(수 테라바이트 이상)의 특정 부분에 효율적으로 접근가능. 필터링이나 집계가 자주 일어나는 컬럼을 클러스터 키로 지정하면 성능이 향상</li>
<li>특징:<ul>
<li>파티셔닝보다 더 세밀한 정렬과 필터링(Pruning)을 가능</li>
<li>스노우플레이크(Snowflake)의 마이크로 파티셔닝과 유사하게, 유사한 값들이 모여 있어 쿼리 시 불필요한 데이터 블록 스캔을 건너뛸 수 있음</li>
</ul>
</li>
</ul>
<p>요약하자면, 빅쿼리에서 파티셔닝은 큰 데이터를 날짜 등의 기준으로 큼직하게 나누어 비용과 스캔량을 줄이는 역할을 하고, 클러스터링은 그 내부에서 데이터를 정렬해두어 구체적인 검색 속도를 최적화하는 역할을 한다.<br>일반적으로 파티셔닝을 먼저 적용하고, 파티션 내에서 클러스터링을 적용하여 성능을 극대화한다.</p>

            </div>
            <footer class="post-footer">
                <div class="post-navigation">
                    <a href="../blog-index.html" class="back-to-blog">← 블로그로 돌아가기</a>
                </div>
            </footer>
        </article>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <!-- Mermaid 라이브러리 추가 -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        // Mermaid 초기화 및 렌더링
        mermaid.initialize({ 
            startOnLoad: false,
            theme: 'default',
            securityLevel: 'loose'
        });
        
        // 페이지 로드 후 실행
        window.addEventListener('DOMContentLoaded', function() {
            // language-mermaid 클래스를 가진 코드 블록 찾기
            document.querySelectorAll('pre code.language-mermaid').forEach(function(codeElement) {
                const pre = codeElement.parentElement;
                const mermaidCode = codeElement.textContent;
                
                // 새로운 mermaid div 생성
                const mermaidDiv = document.createElement('div');
                mermaidDiv.className = 'mermaid';
                mermaidDiv.textContent = mermaidCode;
                
                // pre 태그를 mermaid div로 교체
                pre.parentNode.replaceChild(mermaidDiv, pre);
            });
            
            // Mermaid 렌더링
            mermaid.init(undefined, document.querySelectorAll('.mermaid'));
        });
    </script>
</body>
</html>