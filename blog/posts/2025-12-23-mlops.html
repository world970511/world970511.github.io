<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MLops란 무엇일까? - 박나은</title>
    <meta name="description" content="AI 스터디 내용 정리">
    <meta property="og:title" content="MLops란 무엇일까?">
    <meta property="og:description" content="AI 스터디 내용 정리">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="../../images/favicon/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../../images/favicon/favicon.svg" />
    <link rel="shortcut icon" href="../../images/favicon/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../../images/favicon/apple-touch-icon.png" />
    <link rel="manifest" href="../../images/favicon/site.webmanifest" />
    
    <link rel="stylesheet" href="../../assets/css/styles.css">
    <link rel="stylesheet" href="../../assets/css/blog-post.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <nav class="nav-container">
        <div class="nav-content">
            <a class="nav-brand" href="../../index.html">박나은</a>
            <div class="nav-tabs">
                <a class="nav-tab" href="../blog-index.html">Blog</a>
            </div>
        </div>
    </nav>
    
    <div class="main-container">
        <article class="blog-post-full">
            <header class="post-header">
                <h1 class="post-title">MLops란 무엇일까?</h1>
                <div class="post-meta">
                    <span>📅 2025년 12월 23일</span>
                    <span>⏱️ 7분 읽기</span>
                    <span>📁 Tech</span>
                </div>
                <div class="post-tags">
                    <span class="post-tag">#MLops</span><span class="post-tag">#Infrastructure</span><span class="post-tag">#DevOps</span>
                </div>
            </header>
            <div class="post-content">
                <h1 id="mlops-정리하기">MLops 정리하기.</h1>
<p>이전에 스터디하면서 발표자분이 정말 내용을 꽉꽉 채워 이야기해주셔서 배웠던 게 많았던 발표인데 내용을 정리하지 않으면 영영 까먹을 것 같아 정리해본다.</p>
<h2 id="💡-mlops란-무엇인가">💡 MLOps란 무엇인가?</h2>
<p><strong>MLOps</strong>: 머신러닝 운영(Machine Learning Operations)의 약자로, AI 시스템의 개발, 테스트, 배포, 모니터링 등의 과정을 효율적으로 관리하고 최적화하는 기술을 의미한다.<br><strong>그럼 왜 이런 기술이 필요할까?</strong><br>AI 모델은 시간이 지남에 따라 새로운 패턴의 등장 혹은 데이터 분포의 변화 등으로 성능이 저하되거나 모델의 편향성이 발생할 수 있다. 또한, 여러 버전의 모델이 동시에 개발되면 실험 결과의 일관성이 부족해서 재현성이 낮아지는 문제가 발생한다.<br>때문에 AI 성능의 유지를 위해서는 지속적인 모니터링/ 업데이트가 필요하다. 이때 이를 자동화하고 효율적으로 관리하는 것이 MLOps이다.</p>
<h3 id="✅-mlops의-주요-구성-요소">✅ MLOps의 주요 구성 요소</h3>
<table>
<thead>
<tr>
<th align="left">구성 요소</th>
<th align="left">정의</th>
<th align="left">비고</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>버전 관리</strong><br/>  (Version Control)</td>
<td align="left">데이터, 코드, 모델 바이너리 및 설정의 변경 사항을 체계적으로 추적하고 기록하는 프로세스</td>
<td align="left">• 코드: 모델 학습 및 실험을 위한 코드, 서비스 배포를 위한 코드 등<br/>  • 데이터: 모델 학습 시 사용한 데이터셋, 평가 시에 사용한 데이터셋 등<br/>   • 모델: 각 실험마다 생성된 모델 등<br/>   • 개발환경: 각 실험을 수행하기 위한 개발환경, 서비스 배포를 위한 개발환경 등</td>
</tr>
<tr>
<td align="left"><strong>CI/CD</strong> <br/> (Continuous Integration/Continuous Deployment)</td>
<td align="left">소프트웨어 및 머신러닝 모델의 개발 생애주기를 자동화하고 간소화하기 위한 일련의 관행과 도구</td>
<td align="left">• CI (Continuous Integration): 모델을 지속적으로 통합하고 테스트하는 것<br/> • CD (Continuous Deployment): 자동 배포를 통해 운영 환경에 모델 서비스를 안정적으로 배포하는 것</td>
</tr>
<tr>
<td align="left"><strong>모니터링</strong> <br/> (Monitoring)</td>
<td align="left">실제 운영 환경에서 어떻게 성능을 발휘하는지 체계적으로 추적하고 측정하며 이해하는 일련의 과정</td>
<td align="left">• 모델 성능 및 데이터 품질 모니터링 필요<br/>  • 모델 드리프트 감지, 실시간 경고 시스템 구축</td>
</tr>
</tbody></table>
<h2 id="💡-mlops-파이프라인은-무엇인가">💡 MLOps 파이프라인은 무엇인가?</h2>
<p><strong>파이프라인</strong>: 데이터 수집, 전처리, 모델 학습, 평가, 배포, 모니터링을 포함한 MLOps 전체의 흐름을 이어주는 개념</p>
<h3 id="🛠️-파이프라인의-단계">🛠️ 파이프라인의 단계</h3>
<p>파이프라인은 크게 6가지 단계로 구성된다.</p>
<ol>
<li><strong>데이터 수집</strong> : 다양한 소스로부터 데이터를 수집하고 통합하는 것</li>
<li><strong>데이터 전처리</strong> : 정규화, 결측치 처리, 피처 엔지니어링 등을 통해 모델 학습에 부정적 영향을 끼치는 데이터를 제거하는 것</li>
<li><strong>모델 학습</strong> : 데이터를 기반으로 모델을 학습하는 것.</li>
<li><strong>모델 평가</strong> : 모델의 성능을 평가하는 것. 모델을 평가할 때는 도메인, 모델 알고리즘 등의 종류에 따라서 다양한 평가 지표를 선택할 수 있음. 일반적인 오프라인 지표 테스트 뿐만 아닌, A/B테스트와 같은 온라인 테스트도 수행 가능</li>
<li><strong>모델 배포</strong> : CI/CD를 통해 모델을 배포한다. 이때, 서비스의 목적과 특성 그리고 달성하고자 하는 비즈니스 목표 등에 따라서 배포 전략이 달라질 수 있다. 대표적으로는 실시간 배포와 배치성 배포를 살펴볼 수 있다.</li>
<li><strong>성능 모니터링 및 반복</strong> : 모델의 성능을 모니터링하고 반복하는 것. CICD 파이프라인을 통해 자동 배포 후 모니터링을 통한 성능 확인을 진행한다.</li>
</ol>
<p>이를시각적으로 나타내보면 아래와 같다.</p>
<pre><code class="language-mermaid">%%{init: {&#39;theme&#39;: &#39;base&#39;, &#39;themeVariables&#39;: { &#39;primaryColor&#39;: &#39;#4F46E5&#39;, &#39;primaryTextColor&#39;: &#39;#fff&#39;, &#39;primaryBorderColor&#39;: &#39;#3730A3&#39;, &#39;lineColor&#39;: &#39;#6366F1&#39;, &#39;secondaryColor&#39;: &#39;#F0ABFC&#39;, &#39;tertiaryColor&#39;: &#39;#E0E7FF&#39;}}}%%

flowchart TB
    subgraph Phase1[&quot;1️⃣ 데이터 수집&quot;]
        A1[웹 크롤링] --&gt; A2[API 연동]
        A2 --&gt; A3[데이터베이스 수집]
        A3 --&gt; A4[스트리밍 데이터]
        A4 --&gt; A5[(Raw Data Lake)]
    end

    subgraph Phase2[&quot;2️⃣ 데이터 전처리&quot;]
        B1[데이터 정제] --&gt; B2[결측치/이상치 처리]
        B2 --&gt; B3[피처 엔지니어링]
        B3 --&gt; B4[데이터 검증]
        B4 --&gt; B5[(Feature Store)]
    end

    subgraph Phase3[&quot;3️⃣ 모델 학습&quot;]
        C1[실험 설계] --&gt; C2[하이퍼파라미터 튜닝]
        C2 --&gt; C3[분산 학습]
        C3 --&gt; C4[모델 버저닝]
        C4 --&gt; C5[(Model Registry)]
    end

    subgraph Phase4[&quot;4️⃣ 모델 평가&quot;]
        D1[오프라인 테스트] --&gt; D2[검증 데이터셋 평가]
        D2 --&gt; D3[A/B 테스트]
        D3 --&gt; D4[온라인 테스트]
        D4 --&gt; D5{성능 기준 충족?}
    end

    subgraph Phase5[&quot;5️⃣ 모델 배포 - CI/CD&quot;]
        E1[모델 패키징] --&gt; E2[컨테이너화]
        E2 --&gt; E3[스테이징 배포]
        E3 --&gt; E4[카나리 배포]
        E4 --&gt; E5[프로덕션 배포]
    end

    subgraph Phase6[&quot;6️⃣ 성능 모니터링 및 반복&quot;]
        F1[실시간 메트릭 수집] --&gt; F2[데이터 드리프트 감지]
        F2 --&gt; F3[모델 성능 추적]
        F3 --&gt; F4[알림 시스템]
        F4 --&gt; F5{재학습 필요?}
    end

    %% Main Flow Connections
    Phase1 --&gt; Phase2
    Phase2 --&gt; Phase3
    Phase3 --&gt; Phase4
    
    D5 --&gt;|Yes| Phase5
    D5 --&gt;|No - 재설계| Phase3
    
    Phase5 --&gt; Phase6
    
    F5 --&gt;|Yes - 재학습 트리거| Phase2
    F5 --&gt;|No - 지속 모니터링| F1

    %% Tools &amp; Technologies Labels
    subgraph Tools[&quot;🛠️ 주요 도구 및 기술&quot;]
        T1[&quot;데이터: Airflow, Kafka, Spark&quot;]
        T2[&quot;피처: Feast, Tecton, Hopsworks&quot;]
        T3[&quot;학습: MLflow, Kubeflow, W&amp;B&quot;]
        T4[&quot;평가: Evidently, Great Expectations&quot;]
        T5[&quot;배포: Docker, K8s, ArgoCD&quot;]
        T6[&quot;모니터링: Prometheus, Grafana&quot;]
    end

    style Phase1 fill:#DBEAFE,stroke:#3B82F6,stroke-width:2px
    style Phase2 fill:#FEF3C7,stroke:#F59E0B,stroke-width:2px
    style Phase3 fill:#D1FAE5,stroke:#10B981,stroke-width:2px
    style Phase4 fill:#FCE7F3,stroke:#EC4899,stroke-width:2px
    style Phase5 fill:#E0E7FF,stroke:#6366F1,stroke-width:2px
    style Phase6 fill:#FEE2E2,stroke:#EF4444,stroke-width:2px
    style Tools fill:#F3F4F6,stroke:#9CA3AF,stroke-width:1px,stroke-dasharray: 5 5
</code></pre>
<h3 id="📌-mlops의-tool">📌 MLOps의 tool</h3>
<ul>
<li><strong>Docker</strong>: 모델 및 의존성 환경을 컨테이너화하여 재현성과 이식성을 제공</li>
<li><strong>Kubernetes</strong>: 컨테이너 오케스트레이션 서비스로, 컨테이너화된 애플리케이션의 배포, 확장, 관리를 자동화하는 도구. 안정적인 서비스 운용을 위한 확장성과 자동배포 관리를 지원한다</li>
<li><strong>Prometheus</strong>: 이벤트 모니터링 및 경고에 사용되는 오픈소스 모니터링 툴 (데이터 수집 역할)</li>
<li><strong>Grafana</strong>: 시계열 메트릭 데이터를 시각화하는데 최적화된 오픈소스 툴 (수집한 데이터툴 시각화)</li>
<li><strong>MLFlow</strong>: 머신러닝 모델의 실험을 트래킹하고, 모델을 공유 및 배포하는데 활용할 수 있는 오픈소스 툴. 각 experiment, run마다 메트릭의 성능, 학습에 사용한 코드, 의존성, 데이터, 학습 모델을 백업하고, 해당 내역을 계층적으로 조회해볼 수 있어 버전 관리에 용이함</li>
<li><strong>KubeFlow</strong>: Kubernetes(k8s)를 기반으로 머신러닝 파이프라인을 자동화하는 플랫폼</li>
<li><strong>Jenkins</strong>:CI/CD를 통해 모델 훈련 및 배포 자동화</li>
<li><strong>ArgoCD</strong>: GitOps 방식으로 Kubernetes 배포 관리 (깃에 커밋된 내용을 토대로 자동 배포)</li>
<li><strong>DVC</strong>: 데이터와 모델의 버전 관리를 지원</li>
<li><strong>Kafka</strong>: 실시간 데이터 처리를 위한 메시지 큐</li>
<li><strong>Airflow</strong>: 데이터 워크플로우를 관리하는 오픈소스 툴</li>
<li><strong>Spark</strong>: 분산 컴퓨팅을 위한 오픈소스 툴</li>
</ul>
<h2 id="💡-모니터링과-버전-관리">💡 모니터링과 버전 관리</h2>
<p><strong>모델 모니터링의 중요성:</strong> 데이터 및 모델 성능에 대한 지속적인 모니터링을 통해 모델의 성능이 떨어지는지 아닌지 확인할 필요성이 있다.<br>특히 데이터에 시간이 특성이 반영되는 경우라면, 보편적으로 데이터가 달라질 때 모델의 성능이 떨어지는 현상이 있는데 이를 모델 드리프트라고 한다.<br>이러한 문제점은 재학습 등을 통해 해결할 수 있으나 시간이 지날수록 리소스가 많이 필요해지기 때문에 모니터링을 통해 이를 확인하고 이를 통해 모델을 재학습하는 것이 효율적이다.</p>
<p><strong>버전 관리의 중요성:</strong> 학습에 사용하는 데이터의 버전, 데이터에서 추출한 피처의 버전, 모델 구조의 버전 등 학습 시 결과에 영향을 끼칠 수 있는 다양한 요인이 존재한다. 때문에 이를 잘 기록하여 버전관리를 해야 실수로 재현성을 해치거나 성능을 해치는 경우를 방지할 수 있다.(이때 MLflow나 DVC와 같은 버전 관리 툴을 사용하면 쉽게 관리할 수 있다.)</p>

            </div>
            <footer class="post-footer">
                <div class="post-navigation">
                    <a href="../blog-index.html" class="back-to-blog">← 블로그로 돌아가기</a>
                </div>
            </footer>
        </article>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <!-- Mermaid 라이브러리 추가 -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        // Mermaid 초기화 및 렌더링
        mermaid.initialize({ 
            startOnLoad: false,
            theme: 'default',
            securityLevel: 'loose'
        });
        
        // 페이지 로드 후 실행
        window.addEventListener('DOMContentLoaded', function() {
            // language-mermaid 클래스를 가진 코드 블록 찾기
            document.querySelectorAll('pre code.language-mermaid').forEach(function(codeElement) {
                const pre = codeElement.parentElement;
                const mermaidCode = codeElement.textContent;
                
                // 새로운 mermaid div 생성
                const mermaidDiv = document.createElement('div');
                mermaidDiv.className = 'mermaid';
                mermaidDiv.textContent = mermaidCode;
                
                // pre 태그를 mermaid div로 교체
                pre.parentNode.replaceChild(mermaidDiv, pre);
            });
            
            // Mermaid 렌더링
            mermaid.init(undefined, document.querySelectorAll('.mermaid'));
        });
    </script>
</body>
</html>